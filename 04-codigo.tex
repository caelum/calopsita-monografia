\section{Código}
Todo o código do Calopsita está hospedado no GitHub, local onde também pode ser visualizado todo o histórico e atividades do projeto desde sua concepção. http://github.com/caelum/calopsita/

Antes de iniciar o desenvolvimento do Calopsita, foi discutido quais seriam as escolhas de linguagens e frameworks a serem utilizados. As opções eram: Ruby on Rails ou Java com VRaptor. Como a maioria da equipe era mais familiar com Java do que com Ruby, a escolha foi pelo Java com VRaptor.

\subsection{BDD}
Desde o começo resolvemos adotar boas práticas de desenvolvimento, como {\it Behavior Driven Development} (BDD), 
refatoração constante e programação pareada. Principalmente para usar BDD precisávamos de ferramentas que nos 
ajudassem a escrever testes mais expressivos e legíveis. No mundo do Ruby on Rails essa prática já está bastante 
difundida, então existem várias ferramentas de teste como o RUnit e o Cucumber, além da linguagem ser dinâmica e 
possibilitar a escrita de DSLs e interfaces fluentes de uma maneira bastante direta. Em Java a prática de BDD ainda 
não está muito forte, então não existem ferramentas muito avançadas, além da linguagem ser estática e burocrática, 
que torna o desenvolvimento de tais ferramentas muito mais difícil. Mesmo assim, foram pesquisadas as alternativas:

-JBehave - que possibilita a escrita de arquivos texto com a descrição das funcionalidades, e uma classe Java 
correspondente a esse arquivo. Foi descartado por causa da sua sintaxe pouco produtiva e de algumas limitações, 
como a impossibilidade de compartilhar passos entre features ****melhorar essa frase****
-Cucumber + JRuby - poderíamos também usar o próprio Cucumber do Ruby, usando o JRuby para poder integrar código 
Java aos testes. Foi descartada por causa da complexidade da integração, e por causa da mistura de linguagens.

** o que mais mesmo? **

-JUnit + Bom senso - Não usar nenhuma ferramenta específica, apenas JUnit para rodar os testes, e o bom senso da 
equipe para escrever testes legíveis e expressivos.

Acabamos por optar pela última opção, que era bem mais simples e poderíamos criar uma nova forma de desenvolver 
testes em Java. A nossa solução para testes foi publicada no blog da Caelum: 
http://blog.caelum.com.br/2009/02/28/behavior-driven-development-com-junit/. Essa solução é uma arquitetura de 
testes que possibilita a escrita de testes de aceitação, em Java, quase em linguagem natural. Um exemplo de teste 
escrito nessa arquitetura, tirado do código do calopsita:

TODO -> colorir isso
/**
 * <b>In order to</b> plan what has to be done <br>
 * <b>As a</b> project client <br>
 * <b>I want to</b> create and edit cards (with name and description) <br>
 *
 */
public class CreateACardStory extends DefaultStory {

	@Test
	public void cardCreation() throws Exception {
		given.thereIsAnUserNamed("David").and()
			.thereIsAProjectNamed("Papyrus").ownedBy("David").and()
			.iAmLoggedInAs("David");

		when.iOpenProjectPageOf("Papyrus").and()
		    .iOpenCardsPage().and()
			.iAddTheCard("Incidents").withDescription("create and update an incident").and()
			.iOpenCardsPage();
		then.theCard("Incidents").appearsOnList();
	}
}

que se removermos os ruidos sintáticos e os Camel cases, ficaria:

{\bf In order to} plan what has to be done
{\bf As a} project client
{\bf I want to} create and edit cards (with name and description)

Create a card story:

card creation:
	
		given there is an user Named "David" and
			there is a project named "Papyrus" owned by "David" and
			i am logged in as "David"

		when I open project page of "Papyrus" and
		  I open cards page and
			I add the card "Incidents" with description "create and update an incident" and
			I open cards page
			
		then the card "Incidents" appears on list

Isso é bastante próximo da linguagem natural, em inglês, e possibilita a leitura fácil até para leigos.

Essa arquitetura de testes foi adotada apenas para testes de aceitação, que eram escritos a cada solicitação de
funcionalidade. Para os testes unitários, decidimos apenas usar de refatoração, em especial a 
*****Extract Method - colocar a citação para o livro do Martin Fowler****, possibilitando a escrita de testes bastante
legíveis, mas com um pouco mais de ruidos sintáticos do Java. Um exemplo de teste unitário, tirado do código do calopsita:

TODO- colorir isso

public class IterationTest {
	@Test
	public void addingACardInAnIteration() throws Exception {
		Iteration iteration = givenAnIteration();
		Card card = givenACard();

		shouldUpdateTheCard(card);

		whenIAddTheCardToIteration(card, iteration);

		assertThat(card.getIteration(), is(iteration));
		mockery.assertIsSatisfied();
	}
}

Mesmo com mais ruído sintático é possível entender facilmente o intuito do teste:

Adicionando um cartão em uma iteração:
  dado uma Iteração e
  dado um cartão
  
  deve atualizar o cartão
  
  quando eu adicionar o cartão na iteração
  
  no final, garanta que a iteração do cartão é a iteração acima
  

Dessa forma, a manutenção dos testes fica muito fácil, e pode ser feita facilmente por qualquer pessoa, pois o teste deixa bem claro que está fazendo.


\section{VRaptor}

Como a escolha do Calopsita foi Java com VRaptor, começamos a desenvolver com o VRaptor na versão 2.6. 
Ao mesmo tempo, a versão nova do VRaptor, a 3.0, começou a ser desenvolvida, e por volta de julho já tinha 
uma versão alfa funcional. O VRaptor 3.0 possibilita o desenvolvimento de aplicações RESTful ****citação**** 
e o uso massivo de injeção de dependências ******citação********. Dessa forma, era possível adicionar mais 
características e boas práticas ao Calopsita. O uso de uma interface web RESTful traz várias vantagens para 
uma aplicação web. Usando os verbos HTTP do jeito certo, você consegue aproveitar a semântica da web para a 
sua aplicação, além de conseguir aproveitar recursos dos servidores, como caching. Além disso, a aplicação 
se torna automaticamente um web-service, facilitando a integração com outros sistemas.

Por volta de julho, o calopsita foi totalmente migrado para VRaptor 3, deixando o desenvolvimento mais produtivo. 
Nessa época, o VRaptor ainda não tinha uma versão estável, mas a maneira com o que ele foi feito possibilitava a fácil
personalização e resolução dos problemas que existiam nele. A versão final só saiu no começo de outubro, então durante 
julho e outubro o calopsita auxiliou no desenvolvimento do VRaptor 3, que é um projeto \opensource desenvolvido pela Caelum.

Usar injeção de dependências faz com que a aplicação fique naturalmente mais testável e menos acoplada. Isso aliado a
Factories *** citar o design pattern ***, e o uso de interfaces ao invés de implementações ***** citar o design 
pattern/effective java ****** fez com que as classes do calopsita ficassem bem testáveis unitariamente, possibilitando 
uma cobertura por testes de mais de 85\% (que é bem difícil de se conseguir em projetos java). Isso também auxiliou bastante
o desenvolvimento da arquitetura em plugins do calopsita.

\section{ActiveRecord}

TODO -- mudar isso para estilo de monografia...

O ***http://martinfowler.com/eaaCatalog/activeRecord.html*** padrão Active Record ficou bem famoso após o 
surgimento do <a href="http://rubyonrails.org/">Ruby on Rails</a>, que o usa para fazer a persistência dos 
dados. Em Java, geralmente usamos o padrão ****http://martinfowler.com/eaaCatalog/dataMapper.html*** Data 
Mapper, pois temos ótimos frameworks, como o Hibernate e a JPA, que nos ajudam com a parte de persistência 
e são classificados como tal.

Geralmente, em Java, usamos o Hibernate, e usamos ***citação de design pattern disso?**** DAOs para encapsular 
o acesso a dados. Mas frequentemente nos encontramos escrevendo o seguinte tipo de método, dentro de um DAO:

public List<Aluno> listaAlunosInteressadosNaTurma(Turma turma) {...}

Esse código não está orientado a objetos, embora receba e retorne objetos. Esse mesmo código poderia ser escrito como:

public class Turma {
   //...
   List<Aluno> getAlunosInteressados() {...}
}

que é um código bem mais orientado a objetos.
Existem muitos casos em que daria para fazer algo assim, e não precisaríamos ficar espalhando os DAOs por aí só para fazer esse tipo de consulta. Nessas situações é que usar Active Record deixa o código mais limpo, menos acoplado e mais orientado a objetos. Mas estamos em uma linguagem estática, e as coisas não acontecem <a href="http://rubylearning.com/satishtalim/ruby_method_missing.html">"magicamente"</a> como no Ruby, por exemplo. Precisamos que a <strong>Turma</strong> saiba lidar com o banco de dados, e geralmente passamos pra ela uma <a href="https://www.hibernate.org/hib_docs/v3/api/org/hibernate/Session.html">Session</a> ou um <a href="http://www.techq.com/onlinedoc/jdocs/jee15/api/javax/persistence/EntityManager.html">Entity Manager</a>.</p>
<p>Isso também não é muito legal, pois a <strong>Turma</strong> começa a ficar com milhares de métodos, e com um monte de lógica de consulta ao banco de dados. Uma boa solução é adotar uma idéia que vem do <a href="http://domaindrivendesign.org/">DDD</a>: a Entidade <strong>Turma</strong> tem acesso ao repositório de dados de <strong>Turma</strong>, ou seja, ao <strong>TurmaRepository</strong>. Desse modo, poderíamos ter:</p>
<p><code> </code></p>
<p><code></p>
<pre>public class Turma {
   private TurmaRepository repository;
   ...
   List&lt;Aluno&gt; getAlunosInteressados() {
       return repository.listaAlunosInteressadosNaTurma(this);
   }
}</pre>
<p></code></p>
<p>Ou seja, a entidade continuaria tendo acesso "direto" ao BD e mesmo assim não teríamos um monte de código dentro da entidade para darmos manutenção. Usando essa variante de Active Record, poderíamos ter na nossa entidade tanto acesso aos dados da tabela <strong>Turma</strong>, aos métodos <a href="http://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> para <strong>Turma</strong>, e a algumas consultas ao BD que dependem da turma. Dessa forma, nosso código lá no <strong>AlunoLogic</strong> não precisaria ficar usando vários DAOs "desnecessariamente", bastaria usar as consultas diretamente nas entidades pertinentes.</p>
<p>Claro que essa abordagem não resolve consulta do tipo: <strong>listaTodasAsTurmasDoSistema</strong>, ou <strong>listaTodasAsTurmasFuturas</strong>, e nesse caso, sua lógica de negócio poderia usar o próprio DAO para isso. Mas usando essa idéia, é possível deixar a lógica de negócios muito menos dependente de DAOs, e as entidades muito mais ativas, conseguindo se comunicar com o banco de dados de uma maneira mais limpa e orientada a objetos.</p>



O Calopsita está sendo desenvolvido com a linguagem Java, utilizando ainda Hibernate e javascript. Como framework MVC começamos utilizando o VRaptor 2 e durante o desenvolvimento do VRaptor 3 resolvemos fazer a migração. Muita coisa que precisavamos ainda não contava com o suporte do VRaptor 3, portanto nossa adoção ajudou no desenvolvimento desse framework. Ainda foi a adoção desse framework que nos permitiu a utilização de url's amigáveis, restful, etc. Sua principal vantagem é: blabla




ActiveRecord + ferreira
http://blog.objectmentor.com/articles/2007/11/02/active-record-vs-objects
post do Lucas aqui, ja q n foi publicado

Ainda SeleniumDSL (HtmlUnit x Selenium)

BDD
citar nosso post de BDD, colocar exemplos
http://blog.caelum.com.br/2009/02/28/behavior-driven-development-com-junit/

Desenvolvimento paralelo do VRaptor, um ajudou o outro
lembrar que DI eh design pattern

descricao tecnica (cuidado pra n ficar chato)


