\section{Código}
Todo o código do \calopsita está hospedado no GitHub, local onde também pode ser visualizado todo o histórico e atividades do projeto desde sua concepção.

Antes de iniciar o desenvolvimento do \calopsita, foi discutido quais seriam as escolhas de linguagens e frameworks a 
serem utilizados. As opções eram: Ruby on Rails ou Java com VRaptor. Como a maioria da equipe era mais familiar com Java 
do que com Ruby, a escolha foi pelo Java com VRaptor.

\subsection{BDD} \label{bdd}
Desde o começo resolvemos adotar boas práticas de desenvolvimento, como {\it Behavior Driven Development} (BDD) \cite{bdd}, 
refatoração constante e programação pareada. Principalmente para usar BDD precisávamos de ferramentas que nos 
ajudassem a escrever testes mais expressivos e legíveis. No mundo do Ruby on Rails essa prática já está bastante 
difundida, então existem várias ferramentas de teste como o RSpec~\footnote{http://rspec.info/} e o
Cucumber~\footnote{http://cukes.info/}, além da linguagem ser dinâmica e possibilitar a escrita de DSLs e interfaces
fluentes~\cite{dsl} de uma maneira bastante direta. Em Java a prática de BDD ainda não está muito forte, então não existem
ferramentas muito avançadas, além da linguagem ser estática e burocrática, que torna o desenvolvimento de tais ferramentas 
muito mais difícil. Mesmo assim, foram pesquisadas as alternativas:

\begin{itemize}
	\item{JBehave~\footnote{http://jbehave.org/} - funciona associando um arquivo texto a um código Java. No arquivo texto fica 
	a descrição da funcionalidade, tal como seria escrita num cartão de estória. Foi descartado por causa da sua sintaxe 
	pouco produtiva e de algumas limitações, como a impossibilidade de compartilhar passos (associações entre código Java 
	e etapas da funcionalidade) entre funcionalidades.}
	\item{Cucumber + JRuby~\footnote{http://jruby.org/} - poderíamos também usar o próprio Cucumber do Ruby, usando o JRuby 
	para poder integrar código 
Java aos testes. Foi descartada por causa da complexidade da integração, e por causa da mistura de linguagens 
(isso poderia afastar eventuais colaboradores).}
	\item{JUnit - Não usar nenhuma ferramenta específica, apenas JUnit para rodar os testes, e o bom senso da 
equipe para escrever testes legíveis e expressivos.}
\end{itemize}

Acabamos por optar pela última opção, que era bem mais simples e poderíamos criar uma nova forma de desenvolver 
testes em Java. A nossa solução para testes foi publicada no blog da
Caelum~\footnote{http://blog.caelum.com.br/2009/02/28/behavior-driven-development-com-junit/} e é uma arquitetura de 
testes que possibilita a escrita de testes de aceitação, em Java, quase em linguagem natural. Baseada no Cucumber, criamos 
algumas convenções para aumentar a legibilidade, de acordo com suas responsabilidades:

\begin{itemize}
	\item{GivenSteps given - objeto que vai preparar o contexto inicial do teste em questão. Ex: Entrar em uma página, 
	inserir determinados objetos no banco, logar-se com um dado usuário, etc.}
	\item{WhenSteps when - objeto que vai executar as ações do teste em si, utilizando o contexto definido pelo objeto given. 
	É a parte mais importante do teste. Ex: Preencher um formulário, clicar no botao Enviar, selecionar um item em alguma 
	comboBox, etc.}
	\item{ThenSteps then - objeto que verifica se o resultado das ações executadas é o esperado. Ex: O usuário está logado? 
	Apareceu a mensagem ``Inserido com sucesso''? Deu erro de validação?}
\end{itemize}

Um exemplo de teste escrito nessa arquitetura, tirado do código do \calopsita:

\begin{lstlisting}
/**
 * In order to plan what has to be done
 * As a project client
 * I want to create and edit cards (with name and description)
 *
 */
public class CreateACardStory extends DefaultStory {

	@Test
	public void cardCreation() throws Exception {
		given.thereIsAnUserNamed("David").and()
			.thereIsAProjectNamed("Papyrus").ownedBy("David").and()
			.iAmLoggedInAs("David");

		when.iOpenProjectPageOf("Papyrus").and()
		    .iOpenCardsPage().and()
			.iAddTheCard("Incidents")
				.withDescription("create and update an incident").and()
			.iOpenCardsPage();
		then.theCard("Incidents").appearsOnList();
	}
}
\end{lstlisting}

Repare que se removermos os ruídos sintáticos, ficariámos com:

\begin{verbatim}
In order to plan what has to be done
As a project client
I want to create and edit cards (with name and description)

Create a card story:

card creation:
	
	given there is an user named "David" and
		there is a project named "Papyrus" owned by "David" and
		i am logged in as "David"

	when I open project page of "Papyrus" and
		I open cards page and
		I add the card "Incidents" with description "create and update an incident" and
		I open cards page
			
	then the card "Incidents" appears on list
		then the card "Incidents" appears on list
\end{verbatim}

Isso é bastante próximo da linguagem natural, em inglês, e possibilita a leitura fácil até para leigos.

Essa arquitetura de testes foi adotada apenas para testes de aceitação, que eram escritos a cada solicitação de
funcionalidade. Para os testes unitários, decidimos apenas usar de refatoração, em especial a 
Extract Method~\cite{refactoring}, possibilitando a escrita de testes bastante
legíveis, mas com um pouco mais de ruidos sintáticos do Java. Um exemplo de teste unitário, tirado do código do \calopsita:

\begin{lstlisting}
public class IterationTest {
	@Test
	public void addingACardInAnIteration() throws Exception {
		Iteration iteration = givenAnIteration();
		Card card = givenACard();

		shouldUpdateTheCard(card);

		whenIAddTheCardToIteration(card, iteration);

		assertThat(card.getIteration(), is(iteration));
		mockery.assertIsSatisfied();
	}
}
\end{lstlisting}

Mesmo com mais ruído sintático é possível entender facilmente o intuito do teste:

\begin{verbatim}
Adicionando um cartão em uma iteração:
	dado uma Iteração e
	dado um cartão
  
	deve atualizar o cartão
  
	quando eu adicionar o cartão na iteração
  
	no final, garanta que a iteração do cartão é a iteração acima
\end{verbatim}

Dessa forma, a manutenção dos testes fica muito fácil, e pode ser feita facilmente por qualquer pessoa, pois o 
teste deixa bem claro que está fazendo.


\subsection{VRaptor e Injeção de Dependências}

*****
por que vraptor ao inves de struts? o que ele tinha de bom? framework caseiro? comunidade? caelum?
quais as vantagens do vraptor 3? o que trouxe de novo? inspirado por rails? rest? extensibilidade?
*****

Quando desenvolvemos aplicações web temos geralmente duas escolhas: ser orientado a componentes ou orientado
a ações. Aplicações orientadas a componentes na Web costumam ser meio artificiais demais, pois a Web não
possui suporte nativo a esse tipo de abordagem. Além disso, os \textit{frameworks} existentes para isso em
Java são bastante difíceis de se trabalhar e pouco produtivos. Então resolvemos desenvolver o \calopsita orientado
a ações. Dentre os \textit{frameworks} orientados a ações disponíveis para Java, resolvemos usar o 
VRaptor~\footnote{http://vraptor.caelum.com.br}, por termos mais familiaridade e por acreditar que ele é mais 
produtivo e simples que os outros.

Começamos a desenvolver o \calopsita com o VRaptor na versão 2.6, que era a mais atual na época. 
Ao mesmo tempo, a versão nova do VRaptor, a 3.0, começou a ser desenvolvida, e por volta de julho já tinha 
uma versão alfa funcional. Decidimos então migrar o \calopsita para o VRaptor 3, pois ele trazia mais idéias
e boas práticas, muitas provenientes do Ruby on Rails. Além disso, poderíamos usar o \calopsita para auxiliar
o desenvolvimento do VRaptor 3, que é um projeto \opensource e é desenvolvido também por um dos membros do
\calopsita.

O VRaptor 3.0 possibilita o desenvolvimento de aplicações RESTful \cite{rest}
e o uso massivo de injeção de dependências\cite{di}. O uso de uma interface web RESTful traz várias vantagens para 
uma aplicação web. Usando os verbos HTTP do jeito certo, você consegue aproveitar a semântica da web para a 
sua aplicação, além de conseguir aproveitar recursos dos servidores, como caching. Além disso, a aplicação 
se torna automaticamente um web-service, facilitando a integração com outros sistemas.

Por volta de julho, o \calopsita foi totalmente migrado para VRaptor 3, deixando o desenvolvimento mais produtivo. 
Nessa época, o VRaptor ainda não tinha uma versão estável, mas a maneira com o que ele foi feito possibilitava a fácil
personalização e resolução dos problemas que existiam nele. A versão final só saiu no começo de outubro, então durante 
julho e outubro o \calopsita auxiliou no desenvolvimento e teste das versões beta do VRaptor 3.

Usar injeção de dependências faz com que a aplicação fique naturalmente mais testável e menos acoplada. Isso aliado a
Factory Methods\cite{gof}, e o uso de interfaces ao invés de implementações \cite{effective} fez com que as
classes do \calopsita ficassem bem testáveis unitariamente, possibilitando uma cobertura por testes de mais de 
90\% (que é bem difícil de se conseguir em projetos java). Isso também auxiliou bastante
o desenvolvimento da arquitetura em plugins do \calopsita.

\subsection{ActiveRecord}

O padrão Active Record~\cite{fowler} ficou bem famoso após o surgimento do Ruby on 
Rails~\footnote{http://rubyonrails.org}, que o usa 
para fazer a persistência dos dados. Em Java, geralmente usamos o padrão Data Mapper~\cite{fowler}, pois temos 
ótimos frameworks, como o Hibernate e a JPA, que nos ajudam com a parte de persistência e são classificados como tal.

Geralmente, em Java, usamos o Hibernate, e usamos DAOs~\cite{dao} para encapsular 
o acesso a dados. Mas frequentemente nos encontramos escrevendo o seguinte tipo de método, dentro de um DAO:

\begin{lstlisting}
public List<Aluno> listaAlunosInteressadosNaTurma(Turma turma) {...}
\end{lstlisting}

Esse código não está orientado a objetos, embora receba e retorne objetos. Esse mesmo código poderia ser escrito como:

\begin{lstlisting}
public class Turma {
	//...
	List<Aluno> getAlunosInteressados() {...}
}
\end{lstlisting}

que é um código bem mais orientado a objetos. O Hibernate já possibilita esse tipo de código quando você
tem relacionamentos configurados no seu modelo, através de proxies~\cite{gof}, fazendo a consulta ao banco
só da primeira vez que o método é acessado. Mas nem sempre temos um relacionamento direto, queremos só os alunos
ativos, por exemplo. Nesse caso é preciso o acesso ao banco de dados a partir do modelo e precisamos injetá-lo.
Em Ruby isso é possível através de mixins~\footnote{http://www.rubycentral.com/pickaxe/tut\_modules.html}, que 
interpretam invocações a métodos que não existem no modelo, e traduzem a invocação para uma consulta ao banco 
de dados. Em Java precisamos dos métodos explicitamente declarados, logo não é possível fazer uma herança que 
interprete métodos arbitrários.

A saída foi adotar o padrão Repository do Domain Driven Design~\cite{ddd}, e usar injeção de dependências para
que o modelo receba o seu respectivo repositório de dados. Desse modo, adicionamos métodos que apenas delegam para o
repositório, que vai fazer a consulta ao banco de fato.

Injetar dependências em modelos não é uma tarefa trivial, pois os modelos são criados várias vezes, em várias condições
diferentes, algumas delas feitas internamente pelo Hibernate para criar listagens, por exemplo. Além disso, esses
modelos são criados a partir de parâmetros da requisição Web. Quando o Active Record começou a ser implementado no 
\calopsita, o VRaptor não suportava esse tipo de injeção de dependência, então o próprio \calopsita implementou essa
injeção sobrescrevendo alguns componentes do VRaptor. Mas um pouco antes do VRaptor lançar sua versão final surgiu
um projeto \opensource chamado IOGI~\footnote{http://github.com/rafaeldff/iogi}, que permite criar objetos imutáveis 
a partir de parâmetros da requisição.
Além disso ele possibilita a injeção de dependências, o que fez com que não precisássemos fazer isso no \calopsita,
diminuindo a quantidade de código de infraestrutura existente.

Desse modo criamos modelos ricos, que encapsulam o seu acesso e representação no banco de dados. Assim os controladores
das requisições Web não precisam lidar com operações do banco de dados, eles apenas usam a interface do próprio modelo
para fazer isso.

\subsection{REST}
O termo REST (Representational State Transfer) foi cunhado por Roy Thomas Fielding em sua tese de doutorado~\cite{rest-roy}, 
onde descreve as idéias que levaram à criação do protocolo HTTP.

É um modelo arquitetural para sistemas distribuídos e a idéia básica é que existe um conjunto fixo de operações permitidas 
(verbos) e diversas aplicações se comunicam aplicando este conjunto fixo de operações em recursos existentes, podendo ainda 
solicitar diversas representações destes recursos.

A web é o maior exemplo de uso de uma arquitetura REST, onde os verbos são as operações disponíveis no protocolo (GET, POST,
PUT, DELETE, HEADER, TRACE, OPTIONS), os recursos são identificados pelas URIs e as representações podem ser definidas
através de \textit{Mime Types}~\cite{mimetypes}.

Ao desenhar aplicações REST, pensamos nos recursos a serem disponibilizados pela aplicação e em seus formatos, ao invés de
pensar nas operações.

Jim Webber~\footnote{http://jim.webber.name/bio.html}, arquiteto chefe da ThoughtWorks~\footnote{http://www.thoughtworks.com/},
tem investido grande parte de seu tempo no estudo de arquiteturas REST. Recentemente ministrou uma palestra num evento interno
da Caelum, onde falava sobre \textit{Hypermedia}~\cite{rest-jim}.
Jim está escrevendo um livro junto com Ian Robinson e Savas Parastatidis e tivemos a oportunidade de ler o livro. Nele, Jim 
defende que aplicações RESTful de verdade devem ter hypermedia, e deu um exemplo de implementação em .NET. Resolvemos, junto com
Guilherme Silveira, escrever implementãções disso em Java~\footnote{http://github.com/caelum/rest-client} e 
Ruby~\footnote{http://github.com/caelum/restfulie}, tendo esse trabalho citado por Jim em seu 
blog~\footnote{http://jim.webber.name/2009/10/27/f01ecbd8-9494-42b3-b38c-abb2435d5967.aspx}.
Durante o tempo que Jim esteve no Brasil, tivemos a oportunidade de mostrar o código do \calopsita para ele, que disse ter
ficado impressionado com a clareza e organização do código.

\subsection{SeleniumDSL e testes de aceitação}
*****achar citação de Testes de aceitação*******
No processo de desenvolvimento do \calopsita, foram criados testes de aceitação *****citação***** para todas as
funcionalidades pedidas pelos clientes do projeto. Esses testes são feitos a partir dos cartões pedidos pelos clientes,
e são usados para validar se o cartão está pronto. Geralmente simulam a interação do usuário com o sistema, executando
passos como preencher formulários, clicar em botões, arrastar e soltar componentes. Esses testes de aceitação
foram escritos em dois passos, o primeiro em linguagem praticamente natural como visto na seção \ref{bdd}, e o segundo
foi a implementação real do teste.

Para executar os testes, precisamos da aplicação rodando de verdade num servidor e, então, simular a interação com 
o sistema. E essa interação pode ser simulada de duas formas:
\begin{itemize}
	\item{abrindo um navegador, como o Firefox ou o Safari, e simulando as ações do usuário via javascript. A principal
	ferramenta para isso é o Selenium~\footnote{http://seleniumhq.org/}. Uma das vantagens dessa abordagem é podemos
	acompanhar os passos do teste visualmente, ficando fácil identificar os erros do teste. Entre as desvantagens podemos
	citar a demora da execução dos testes, pois envolve a criação de novos processos no sistema operacional: o navegador
	precisa ser aberto, além de requerir um servidor do Selenium rodando.}
	\item{criar as páginas da aplição em memória. A principal ferramenta para isso, em Java, é o 
	HtmlUnit~\footnote{http://htmlunit.sourceforge.net/}. Uma das vantagens é que, por fazer tudo em memória, a execução
	dos testes é bem mais rápida. Mas por ser em memória, não é possível visualizar a execução do teste, o que torna
	a depuração bem mais complicada.}
\end{itemize}

O \calopsita começou usando o Selenium para os seus testes de aceitação. Mas a interface do Selenium para Java é bastante
difícil de utilizar, além de não ser nada orientada a objetos: uma única interface com quase 150 métodos que contém todas
as ações para uma página possíveis. Por causa disso, muitos projetos surgiram para tornar essa interface mais agradável
de trabalhar. Um desses projetos é o SeleniumDSL~\footnote{http://github.com/caelum/selenium-dsl}, que é um projeto 
\opensource desenvolvido por pessoas da Caelum, inclusive os membros do \calopsita. O Selenium DSL é um Façade~\cite{gof}
que transforma a interface procedural numa interface fluente~\cite{dsl} e orientada a objetos.

Um dos problemas do Selenium é quando você tenta configurá-lo em um processo de Integração Contínua~\cite{ci}. Por precisar
de recursos externos ao teste (servidor do selenium e navegadores sendo abertos), as máquinas que vão rodar o teste de fato
precisam de um servidor gráfico rodando, dificultando bastante a instalação dessas máquinas. Por esse motivo, resolvemos
migrar os testes para o HtmlUnit.

Como a API SeleniumDSL é toda baseada em interface, decidimos criar, usando o \calopsita como base, uma implementação para
HtmlUnit, transformando assim o SeleniumDSL num Adapter~\cite{gof}: não foi preciso mudar a implementação dos testes no 
\calopsita, tudo continuou funcionando quando a implementação do SeleniumDSL foi trocada. Além disso, a interface fluente
do SeleniumDSL tem um único ponto de entrada, assim trocar da implementação em Selenium para a em HtmlUnit envolve apenas
a mudança de uma linha de código. Por isso, criamos uma Factory~\cite{gof} que decide qual das implementações do SeleniumDSL
vai ser usada, fazendo com que aproveitássemos as vantagens das duas formas de fazer testes para a web: usar o Selenium 
durante o desenvolvimento dos testes, para facilitar a depuração, e usar o HtmlUnit para rodar os testes no ambiente de
integração contínua, para maior rapidez nos testes e maior simplicidade. Essa implementação de HtmlUnit
para SeleniumDSL rendeu uma palestra num evento interno da Caelum~\footnote{http://www.youtube.com/watch?v=5oFlh\_Ka65U\&feature=related}.

\subsection{Arquitetura em plugins}



\subsection{Organização do código}



O \calopsita está sendo desenvolvido com a linguagem Java, utilizando ainda Hibernate e javascript. Como 
framework MVC começamos utilizando o VRaptor 2 e durante o desenvolvimento do VRaptor 3 resolvemos fazer a migração. 
Muita coisa que precisavamos ainda não contava com o suporte do VRaptor 3, portanto nossa adoção ajudou no 
desenvolvimento desse framework. Ainda foi a adoção desse framework que nos permitiu a utilização de url's 
amigáveis, restful, etc. Sua principal vantagem é: blabla
