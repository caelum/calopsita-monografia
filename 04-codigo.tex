\section{Código}
Todo o código do Calopsita está hospedado no GitHub, local onde também pode ser visualizado todo o histórico e atividades do projeto desde sua concepção.

Antes de iniciar o desenvolvimento do Calopsita, foi discutido quais seriam as escolhas de linguagens e frameworks a serem utilizados. As opções eram: Ruby on Rails ou Java com VRaptor. Como a maioria da equipe era mais familiar com Java do que com Ruby, a escolha foi pelo Java com VRaptor.

\subsection{BDD}
Desde o começo resolvemos adotar boas práticas de desenvolvimento, como {\it Behavior Driven Development} (BDD), 
refatoração constante e programação pareada. Principalmente para usar BDD precisávamos de ferramentas que nos 
ajudassem a escrever testes mais expressivos e legíveis. No mundo do Ruby on Rails essa prática já está bastante 
difundida, então existem várias ferramentas de teste como o RSpec~\footnote{http://rspec.info/} e o Cucumber~\footnote{http://cukes.info/}, além da linguagem ser dinâmica e possibilitar a escrita de DSLs e interfaces fluentes~\cite{dsl} de uma maneira bastante direta. Em Java a prática de BDD ainda não está muito forte, então não existem ferramentas muito avançadas, além da linguagem ser estática e burocrática, que torna o desenvolvimento de tais ferramentas muito mais difícil. Mesmo assim, foram pesquisadas as alternativas:

\begin{itemize}
	\item{JBehave~\footnote{http://jbehave.org/} - funciona associando um arquivo texto a um código Java. No arquivo texto fica a descrição da funcionalidade, tal como seria escrita num cartão de estória. Foi descartado por causa da sua sintaxe pouco produtiva e de algumas limitações, como a impossibilidade de compartilhar passos (associações entre código Java e etapas da funcionalidade) entre funcionalidades.}
	\item{Cucumber + JRuby~\footnote{http://jruby.org/} - poderíamos também usar o próprio Cucumber do Ruby, usando o JRuby para poder integrar código 
Java aos testes. Foi descartada por causa da complexidade da integração, e por causa da mistura de linguagens (isso poderia afastar eventuais colaboradores).}
	\item{JUnit - Não usar nenhuma ferramenta específica, apenas JUnit para rodar os testes, e o bom senso da 
equipe para escrever testes legíveis e expressivos.}
\end{itemize}

Acabamos por optar pela última opção, que era bem mais simples e poderíamos criar uma nova forma de desenvolver 
testes em Java. A nossa solução para testes foi publicada no blog da Caelum~\footnote{http://blog.caelum.com.br/2009/02/28/behavior-driven-development-com-junit/} e é uma arquitetura de 
testes que possibilita a escrita de testes de aceitação, em Java, quase em linguagem natural. Baseada no Cucumber, criamos algumas convenções para aumentar a legibilidade, de acordo com suas responsabilidades:

\begin{itemize}
	\item{GivenSteps given - objeto que vai preparar o contexto inicial do teste em questão. Ex: Entrar em uma página, inserir determinados objetos no banco, logar-se com um dado usuário, etc.}
	\item{WhenSteps when - objeto que vai executar as ações do teste em si, utilizando o contexto definido pelo objeto given. É a parte mais importante do teste. Ex: Preencher um formulário, clicar no botao Enviar, selecionar um item em alguma comboBox, etc.}
	\item{ThenSteps then - objeto que verifica se o resultado das ações executadas é o esperado. Ex: O usuário está logado? Apareceu a mensagem ``Inserido com sucesso''? Deu erro de validação?}
\end{itemize}

Um exemplo de teste escrito nessa arquitetura, tirado do código do calopsita:

\begin{lstlisting}
/**
 * In order to plan what has to be done
 * As a project client
 * I want to create and edit cards (with name and description)
 *
 */
public class CreateACardStory extends DefaultStory {

	@Test
	public void cardCreation() throws Exception {
		given.thereIsAnUserNamed("David").and()
			.thereIsAProjectNamed("Papyrus").ownedBy("David").and()
			.iAmLoggedInAs("David");

		when.iOpenProjectPageOf("Papyrus").and()
		    .iOpenCardsPage().and()
			.iAddTheCard("Incidents")
				.withDescription("create and update an incident").and()
			.iOpenCardsPage();
		then.theCard("Incidents").appearsOnList();
	}
}
\end{lstlisting}

Repare que se removermos os ruídos sintáticos, ficariámos com:

\begin{verbatim}
In order to plan what has to be done
As a project client
I want to create and edit cards (with name and description)

Create a card story:

card creation:
	
	given there is an user named "David" and
		there is a project named "Papyrus" owned by "David" and
		i am logged in as "David"

	when I open project page of "Papyrus" and
		I open cards page and
		I add the card "Incidents" with description "create and update an incident" and
		I open cards page
			
	then the card "Incidents" appears on list
		then the card "Incidents" appears on list
\end{verbatim}

Isso é bastante próximo da linguagem natural, em inglês, e possibilita a leitura fácil até para leigos.

Essa arquitetura de testes foi adotada apenas para testes de aceitação, que eram escritos a cada solicitação de
funcionalidade. Para os testes unitários, decidimos apenas usar de refatoração, em especial a Extract Method~\cite{refactoring}, possibilitando a escrita de testes bastante
legíveis, mas com um pouco mais de ruidos sintáticos do Java. Um exemplo de teste unitário, tirado do código do calopsita:

\begin{lstlisting}
public class IterationTest {
	@Test
	public void addingACardInAnIteration() throws Exception {
		Iteration iteration = givenAnIteration();
		Card card = givenACard();

		shouldUpdateTheCard(card);

		whenIAddTheCardToIteration(card, iteration);

		assertThat(card.getIteration(), is(iteration));
		mockery.assertIsSatisfied();
	}
}
\end{lstlisting}

Mesmo com mais ruído sintático é possível entender facilmente o intuito do teste:

\begin{verbatim}
Adicionando um cartão em uma iteração:
	dado uma Iteração e
	dado um cartão
  
	deve atualizar o cartão
  
	quando eu adicionar o cartão na iteração
  
	no final, garanta que a iteração do cartão é a iteração acima
\end{verbatim}

Dessa forma, a manutenção dos testes fica muito fácil, e pode ser feita facilmente por qualquer pessoa, pois o teste deixa bem claro que está fazendo.


\subsection{VRaptor e Injeção de Dependências}

*****
por que vraptor ao inves de struts? o que ele tinha de bom? framework caseiro? comunidade? caelum?
quais as vantagens do vraptor 3? o que trouxe de novo? inspirado por rails? rest? extensibilidade?
quando falar de rest, citar jim webber =D, falar que ele viu o codigo do calops, parte de testes, etc
*****

Como a escolha do Calopsita foi Java com VRaptor, começamos a desenvolver com o VRaptor na versão 2.6. 
Ao mesmo tempo, a versão nova do VRaptor, a 3.0, começou a ser desenvolvida, e por volta de julho já tinha 
uma versão alfa funcional. O VRaptor 3.0 possibilita o desenvolvimento de aplicações RESTful \cite{rest}
e o uso massivo de injeção de dependências\cite{dsl}. Dessa forma, era possível adicionar mais 
características e boas práticas ao Calopsita. O uso de uma interface web RESTful traz várias vantagens para 
uma aplicação web. Usando os verbos HTTP do jeito certo, você consegue aproveitar a semântica da web para a 
sua aplicação, além de conseguir aproveitar recursos dos servidores, como caching. Além disso, a aplicação 
se torna automaticamente um web-service, facilitando a integração com outros sistemas.

Por volta de julho, o calopsita foi totalmente migrado para VRaptor 3, deixando o desenvolvimento mais produtivo. 
Nessa época, o VRaptor ainda não tinha uma versão estável, mas a maneira com o que ele foi feito possibilitava a fácil
personalização e resolução dos problemas que existiam nele. A versão final só saiu no começo de outubro, então durante 
julho e outubro o calopsita auxiliou no desenvolvimento do VRaptor 3, que é um projeto \opensource desenvolvido pela Caelum.

Usar injeção de dependências faz com que a aplicação fique naturalmente mais testável e menos acoplada. Isso aliado a
Factory Methods\cite{gof}, e o uso de interfaces ao invés de implementações \cite{interfaces-effective} fez com que as
 classes do calopsita ficassem bem testáveis unitariamente, possibilitando 
uma cobertura por testes de mais de 85\% (que é bem difícil de se conseguir em projetos java). Isso também auxiliou bastante
o desenvolvimento da arquitetura em plugins do calopsita.

\subsection{ActiveRecord}

O padrão Active Record \cite{activeRecord} ficou bem famoso após o surgimento do Ruby on Rails\cite{RoR}, que o usa 
para fazer a persistência dos dados. Em Java, geralmente usamos o padrão Data Mapper \cite{dataMapper}, pois temos 
ótimos frameworks, como o Hibernate e a JPA, que nos ajudam com a parte de persistência e são classificados como tal.

Geralmente, em Java, usamos o Hibernate, e usamos DAOs\cite{dao} para encapsular 
o acesso a dados. Mas frequentemente nos encontramos escrevendo o seguinte tipo de método, dentro de um DAO:

\begin{lstlisting}
public List<Aluno> listaAlunosInteressadosNaTurma(Turma turma) {...}
\end{lstlisting}

Esse código não está orientado a objetos, embora receba e retorne objetos. Esse mesmo código poderia ser escrito como:

\begin{lstlisting}
public class Turma {
	//...
	List<Aluno> getAlunosInteressados() {...}
}
\end{lstlisting}

que é um código bem mais orientado a objetos. O Hibernate já possibilita esse tipo de código quando você
tem relacionamentos configurados no seu modelo, através de *****citação***** proxies, fazendo a consulta ao banco
só da primeira vez que o método é acessado. Mas nem sempre temos um relacionamento direto, queremos só os alunos
ativos, por exemplo. Nesse caso é preciso o acesso ao banco de dados a partir do modelo e precisamos injetá-lo.
Em Ruby isso é possível através de ***citação**** mixins, que interpretam invocações a métodos que não existem no
modelo, e traduzindo a invocação para uma consulta ao banco de dados. Em Java precisamos dos métodos explicitamente
declarados, logo não é possível fazer uma herança que interprete métodos arbitrários.

A saída foi adotar o padrão Repository do Domain Driven Design *****citação*****, e usar injeção de dependências para
que o modelo receba o seu respectivo repositório de dados. Desse modo, adicionamos métodos que apenas delegam para o
repositório, que vai fazer a consulta ao banco de fato.

Injetar dependências em modelos não é uma tarefa trivial, pois os modelos são criados várias vezes, em várias condições
diferentes, algumas delas feitas internamente pelo Hibernate para criar listagens, por exemplo. Além disso, esses
modelos são criados a partir de parâmetros da requisição Web. Quando o Active Record começou a ser implementado no 
calopsita, o VRaptor não suportava esse tipo de injeção de dependência, então o próprio calopsita implementou essa
injeção sobrescrevendo alguns componentes do VRaptor. Mas um pouco antes do VRaptor lançar sua versão final surgiu
um projeto \opensource chamado IOGI, que permite criar objetos imutáveis a partir de parâmetros da requisição.
Além disso ele possibilita a injeção de dependências, o que fez com que não precisássemos fazer isso no calopsita,
diminuindo a quantidade de código de infraestrutura existente.

Desse modo criamos modelos ricos, que encapsulam o seu acesso e representação no banco de dados. Assim os controladores
das requisições Web não precisam lidar com operações do banco de dados, eles apenas usam a interface do próprio modelo
para fazer isso.


\subsection{REST}

\subsection{SeleniumDSL e testes de aceitação}

\subsection{Organização do código}
O Calopsita está sendo desenvolvido com a linguagem Java, utilizando ainda Hibernate e javascript. Como framework MVC começamos utilizando o VRaptor 2 e durante o desenvolvimento do VRaptor 3 resolvemos fazer a migração. Muita coisa que precisavamos ainda não contava com o suporte do VRaptor 3, portanto nossa adoção ajudou no desenvolvimento desse framework. Ainda foi a adoção desse framework que nos permitiu a utilização de url's amigáveis, restful, etc. Sua principal vantagem é: blabla




ActiveRecord + ferreira
http://blog.objectmentor.com/articles/2007/11/02/active-record-vs-objects
post do Lucas aqui, ja q n foi publicado

Ainda SeleniumDSL (HtmlUnit x Selenium)

BDD
citar nosso post de BDD, colocar exemplos
http://blog.caelum.com.br/2009/02/28/behavior-driven-development-com-junit/

Desenvolvimento paralelo do VRaptor, um ajudou o outro
lembrar que DI eh design pattern

descricao tecnica (cuidado pra n ficar chato)


